36
algorithm:
We’ll iterate through each word in the words array.
For each word, we’ll check if it starts with the given pref.
If it does, we’ll increment a counter to keep track of the number of valid strings.
We use the startswith method to check if each word starts with the given prefix.
If it does, we increment the count.
The final count represents the number of strings in words that contain pref as a prefix.
code:
def count_prefix_strings(words, pref):
    count = 0
    for word in words:
        if word.startswith(pref):
            count += 1
    return count
words = ["pay", "attention", "practice", "attend"]
pref = "at"
print(count_prefix_strings(words, pref))
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
37
algorithm:
Traverse the matrix and mark the rows and columns that need to be set to 0.
Iterate through the matrix again and set the entire row and column to 0 if the corresponding row or column was marked in the previous step.
We use the first row and first column to mark which rows and columns need to be set to 0.
After marking, we traverse the matrix again to update the elements based on the marks.
Finally, we handle the first row and first column separately.
code:
def set_zeroes(matrix):
    rows, cols = len(matrix), len(matrix[0])
    first_row_has_zero = any(matrix[0][j] == 0 for j in range(cols))
    first_col_has_zero = any(matrix[i][0] == 0 for i in range(rows))
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][j] == 0:
                matrix[i][0] = 0
                matrix[0][j] = 0
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0
    if first_row_has_zero:
        for j in range(cols):
            matrix[0][j] = 0
    if first_col_has_zero:
        for i in range(rows):
            matrix[i][0] = 0
matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]
set_zeroes(matrix)
print(matrix)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
38
algorithm:
We convert both input arrays to sets to take advantage of set operations.
The & operator computes the intersection of two sets.
Finally, we convert the resulting set back to a list.
code:
def find_intersection(nums1, nums2):
    set1 = set(nums1)
    set2 = set(nums2)
    intersection = set1 & set2
    result = list(intersection)
    return result
nums1 = [1, 2, 2, 1]
nums2 = [2, 2]
print(find_intersection(nums1, nums2))
nums3 = [4, 9, 5]
nums4 = [9, 4, 9, 8, 4]
print(find_intersection(nums3, nums4))
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
39
algorithm:
We’ll iterate through each position in the string of size n.
For each position, we’ll consider all possible characters from 'a' to 'z'.
If the character is greater than or equal to the corresponding character in s1 and less than or equal to the corresponding
character in s2, we’ll recursively generate the remaining part of the string.
While generating the string, we’ll avoid any substring that contains the string evil.
We’ll use dynamic programming to memoize the results for efficiency.
code:
MOD = 10**9 + 7
def count_good_strings(n, s1, s2, evil):
    def dfs(pos, prefix, evil_seen):
        if pos == n:
            return 1
        if (pos, prefix, evil_seen) in memo:
            return memo[(pos, prefix, evil_seen)]
        count = 0
        for char in range(ord('a'), ord('z') + 1):
            next_prefix = prefix + chr(char)
            if s1 <= next_prefix <= s2:
                next_evil_seen = evil_seen or (evil in next_prefix)
                if not next_evil_seen:
                    count = (count + dfs(pos + 1, next_prefix, next_evil_seen)) % MOD
        memo[(pos, prefix, evil_seen)] = count
        return count
    memo = {}
    return dfs(0, "", False)
n = 2
s1 = "aa"
s2 = "da"
evil = "b"
print(count_good_strings(n, s1, s2, evil)) 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
40
algorithm:
nitialize the dimensions of the input matrix: rows and cols.
Create a new matrix called transposed with dimensions swapped (rows become columns and vice versa). Initialize it with zeros.
Iterate through each element in the original matrix:
For each element at position (i, j) in the input matrix, assign it to position (j, i) in the transposed matrix.
Return the transposed matrix as the final result.
code:
def transpose_matrix(matrix):
    rows, cols = len(matrix), len(matrix[0])
    transposed = [[0] * rows for _ in range(cols)]
    for i in range(rows):
        for j in range(cols):
            transposed[j][i] = matrix[i][j]
    return transposed
matrix1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
result1 = transpose_matrix(matrix1)
print(result1)
matrix2 = [[1, 2, 3], [4, 5, 6]]
result2 = transpose_matrix(matrix2)
print(result2) 
------------------------------------------------------------------------------------------------------------------------------------------------------------------






